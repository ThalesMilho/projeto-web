SÃ³cio, o Backend estÃ¡ pronto. Clona o repositÃ³rio, roda pip install -r requirements.txt e sobe o servidor. A documentaÃ§Ã£o estÃ¡ em /swagger/

SeguranÃ§a

âŒ Logs de auditoria financeira

âŒ Rate limiting em login

âŒ Lock otimista/pessimista de saldo

âŒ Monitoramento de fraude

âŒ Mascaramento de CPF em logs

ğŸ§ª Qualidade

âŒ Testes de concorrÃªncia (race condition)

âŒ Testes de rollback financeiro

âŒ Testes de idempotÃªncia

ğŸ§® NegÃ³cio (quando vier games/)

âŒ ValidaÃ§Ã£o de aposta duplicada

âŒ PrevenÃ§Ã£o de aposta apÃ³s fechamento

âŒ Edge cases (0000, grupo invÃ¡lido, empate)






with transaction.atomic():
    user = request.user
    valor = serializer.validated_data['valor']

    user.saldo -= valor
    user.save()



O que estÃ¡ errado (gravÃ­ssimo)

Race Condition clÃ¡ssica

Dois requests simultÃ¢neos:

Ambos leem o mesmo saldo

Ambos passam na validaÃ§Ã£o

Ambos debitam
â¡ï¸ UsuÃ¡rio aposta duas vezes com o mesmo dinheiro

transaction.atomic() NÃƒO RESOLVE isso sozinho.


from django.db.models import F

with transaction.atomic():
    user = (
        type(request.user)
        .objects
        .select_for_update()
        .get(pk=request.user.pk)
    )

    if user.saldo < valor:
        raise ValidationError("Saldo insuficiente")

    user.saldo = F('saldo') - valor
    user.save(update_fields=['saldo'])








CriarApostaSerializer.validate
if user.saldo < valor_aposta:
    raise serializers.ValidationError(...)

âŒ Por que isso Ã© perigoso

ValidaÃ§Ã£o ocorre ANTES da transaÃ§Ã£o

Saldo pode mudar entre validate() e save()

Falsa sensaÃ§Ã£o de seguranÃ§a

âœ… CorreÃ§Ã£o

â¡ï¸ Remover validaÃ§Ã£o de saldo do serializer
â¡ï¸ Validar dentro da transaÃ§Ã£o, com lock

Serializer valida formato, nÃ£o dinheiro.








PROBLEMA 3 â€” Uso de float em dinheiro (inaceitÃ¡vel)
ğŸ“ ApuracaoView
multiplicador = 5000.0
premio = float(aposta.valor) * multiplicador
usuario.saldo += Decimal(premio)

âŒ Erro conceitual grave

float introduz erro binÃ¡rio

ConversÃ£o float â†’ Decimal Ã© imprecisa

Isso gera centavos fantasmas

âœ… CorreÃ§Ã£o obrigatÃ³ria
multiplicador = Decimal('5000')
premio = aposta.valor * multiplicador
usuario.saldo = F('saldo') + premio


NUNCA use float em sistema financeiro.





PROBLEMA 4 â€” ApuraÃ§Ã£o sem lock no usuÃ¡rio
ğŸ“ ApuracaoView
usuario = aposta.usuario
usuario.saldo += Decimal(premio)
usuario.save()

âŒ Problema

UsuÃ¡rio pode:

apostar

receber prÃªmio

apostar de novo
â€¦ ao mesmo tempo

â¡ï¸ CorrupÃ§Ã£o de saldo.

âœ… CorreÃ§Ã£o
usuario = (
    type(aposta.usuario)
    .objects
    .select_for_update()
    .get(pk=aposta.usuario.pk)
)
usuario.saldo = F('saldo') + premio
usuario.save(update_fields=['saldo'])

ğŸ”¥ PROBLEMA 5 â€” ApuraÃ§Ã£o NÃƒO Ã‰ idempotente
ğŸ“ ApuracaoView

Se o admin chamar a rota duas vezes:

O sorteio ainda estÃ¡ aberto

Apostas ainda ganhou=False no inÃ­cio
â¡ï¸ Pagamento DUPLICADO

âœ… CorreÃ§Ã£o obrigatÃ³ria
if sorteio.fechado:
    return Response(
        {"erro": "Sorteio jÃ¡ apurado"},
        status=400
    )


E feche ANTES de pagar:

with transaction.atomic():
    sorteio = Sorteio.objects.select_for_update().get(pk=pk)
    sorteio.fechado = True
    sorteio.save()









6ï¸âƒ£ Pontos Cegos CRÃTICOS
âŒ NÃƒO EXISTE:

Ledger financeiro (extrato)

HistÃ³rico de transaÃ§Ãµes

Log de auditoria

Rollback manual

Testes de concorrÃªncia

Rate limiting administrativo

Assinatura de comprovante (hash)




7ï¸âƒ£ ConclusÃ£o Honesta

âœ”ï¸ Didaticamente: excelente projeto
âŒ Financeiramente: inseguro
âŒ ProduÃ§Ã£o: NÃƒO PODE SUBIR

Se vocÃª quiser, no prÃ³ximo passo eu posso:

Refatorar toda a apuraÃ§Ã£o em service layer

Criar Ledger Financeiro correto

Tornar o sistema idempotente

Escrever testes de race condition

Preparar checklist prÃ©-deploy real